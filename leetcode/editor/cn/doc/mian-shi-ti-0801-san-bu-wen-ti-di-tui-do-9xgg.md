# [面试题 08.01. 三步问题](https://leetcode-cn.com/problems/three-steps-problem-lcci/)

递推大家都会

这里提供一个矩阵快速幂的方法

设计矩阵

| *a0* | *a1* | *a2* |      | 工     |      | 具     |      | *a1* | *a2* | *a3* |      | *a1* | *a2* | *a0 + a1 + a2* |
| ---- | ---- | ---- | ---- | ------ | ---- | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | -------------- |
| *0*  | *0*  | *0*  | ***  |        |      |        | *=*  | *0*  | *0*  | 0    | *=*  | *0*  | *0*  | *0*            |
| *0*  | *0*  | *0*  |      | **矩** |      | **矩** |      | *0*  | *0*  | *0*  |      | *0*  | *0*  | *0*            |

口算得出工具矩阵为：

| *0*  | *0*  | *1*  |
| ---- | ---- | ---- |
| *1*  | *0*  | *1*  |
| *0*  | *1*  | *1*  |

可见原矩阵**乘于N个工具矩阵**，**（0， 0）位置就是aN**

以得求出aN就是**求原矩阵与N个工具矩阵相乘**

即**矩阵快速幂**

## 矩阵快速幂

````c++
class Solution {
public:
    int waysToStep(int n) {
        long A[3][3] = {1, 1, 2, 0, 0, 0, 0, 0, 0}; //原矩阵
        long B[3][3] = {0, 0, 1, 1, 0, 1, 0, 1, 1}; //工具矩阵
        long C[3][3] = {1, 0, 0, 0, 1, 0, 0, 0, 1}; //单位矩阵
        while(n){  //快速幂
            if(n & 1) muti(C, B);
            n >>= 1;
            muti(B, B);
        }
        muti(A, C);
        return A[0][0] % M; //答案
    }
private:
    const int M = 1000000007;
    void muti(long (*A)[3], long (*B)[3]){ //矩阵乘法
        long C[3][3] = {0, 0, 0, 0, 0, 0, 0, 0, 0}; //0矩阵
        for(int i = 0; i < 3; ++i)  //warshall算法
            for(int j = 0; j < 3; ++j)
                for(int k = 0; k < 3; ++k)
                    C[i][j] += (A[i][k] * B[k][j]) % M;
        for(int i = 0; i < 3; ++i)  //赋值到A上，相当于A *= B
            for(int j = 0; j < 3; ++j)
                A[i][j] = C[i][j];
    }
};
````